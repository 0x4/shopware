<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>Shopware 4 - Einf&uuml;hrung Selenium Test</title>
		<link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
		
		<link rel="stylesheet" href="css/bootstrap.css" />
		<link rel="stylesheet" href="css/style.css" />
		<link rel="stylesheet" href="css/prettify.css" />
	</head>
	<body>
	
	<div class="topbar" data-scrollspy="scrollspy">
		<div class="fill">
			<div class="container">
				<h3><a href="#">SW4 - Selenium Test</a></h3>
				
				<ul>
					<li>
						<a href="#intro">Intro</a>
					</li>
					<li>
						<a href="#structure">Adressierung</a>
					</li>
					<li class="dropdown" data-dropdown="dropdown">
						<a href="#" class="dropdown-toggle">Komponenten</a>
						<ul class="dropdown-menu">
							<li>
								<a href="#paging">Paging-Toolbar</a>
							</li>
							<li>
								<a href="#combobox">Combobox</a>
							</li>
							<li>
								<a href="#ajax-combobox">AJAX-Combobox</a>
							</li>
						</ul>
					</li>
				</ul>
			</div>
		</div>
	</div>
	
	<div class="container">
		<section id="intro">
			<div class="page-header">
				<h2>Shopware 4 Selenium Tests - Einf&uuml;hrung </h2>
			</div>
			<div class="row">
				<div class="span16">
					<p>
						Das Testen von ExtJS 4 Komponenten mit Selenium ist nicht ganz so einfach, wie eine normale Website zu testen, aber mit ein paar Tipps und Tricks sowie gewisse Kenntnisse &uuml;ber CSS3 Selektoren kein Problem. Wer sich unsicher &uuml;ber seine Kenntnisse bez&uuml;glich CSS3 Selektoren ist, der sollte sich vorher ein mal das Tutorial <a href="http://net.tutsplus.com/tutorials/html-css-techniques/the-30-css-selectors-you-must-memorize/" target="_blank">"The 30 CSS Selectors You Must Memorize"</a> von nettuts.com durchlesen.
					</p>
					
					<h4>Voraussetzungen:</h4>
					
					<ul>
						<li>Firefox mit installierten <a href="http://release.seleniumhq.org/selenium-ide/1.4.1/selenium-ide-1.4.1.xpi">Selenium IDE Plugin</a></li>
						<li>CSS3 Selektoren Kenntnisse</li>
						<li><a href="https://addons.mozilla.org/de/firefox/addon/firebug/" target="_blank">Firebug</a> + <a href="https://addons.mozilla.org/de/firefox/addon/firepath/" target="_blank">FirePath (optional)</a></li>
						<li><a href="https://addons.mozilla.org/en-US/firefox/addon/selenium-ide-php-formatters/" target="_blank">Selenium IDE PHP Formatter</a></li>
					</ul>
				</div>
			</div>
		</section>
		
		<section id="adressing">
			<div class="page-header">
				<h2>Adressierung <small>von Backend Modulen</small></h2>
			</div>
			
			<div class="row">
				<div class="span16">
					<p>
						Beim Erstellen eines neuen Shopware 4 Backend Moduls sind bestimmte Richtlinien einzuhalten - darunter befindet sich unter anderen der Punkt "Widget- bzw. Aliasnamen" hinterlegen. Wenn wir jetzt zum Beispiel eine Komponenten mit den Namen <code>"Shopware.apps.Auth.view.main.Create"</code> haben, dann sollte der Widgetname <code>"auth-main-create"</code> sein. Dies bringt den Vorteil dass der Widgetname auch als ID-Prefix genutzt wird und dieser eindeutig in Selenium angesprochen werden kann.
					</p>
				
<pre class="prettyprint lang-js linenums">Ext.define('Shopware.apps.Auth.view.main.Create', {
	extends: 'Ext.window.Window',
	alias: 'widget.auth-main-create',
	autoShow: true,
	width: 650,
	height: 400
});</pre>

				<p>
					Dieses Beispiel ergibt dann folgendes Markup im Quelltext:
				</p>
				
				<p>
					<img src="selenium/dom-element-window.png" />
				</p>
				
				<p>
					Wie man sieht befindet haben wir jetzt eine ID, die man per CSS3 Selektor ansprechen kann.
				</p>
				
<pre class="prettyprint-dark lang-css">div[id^=auth-main-create]</pre>

				<p>
					<img src="selenium/selenium-1.png" />
				</p>
				
				<p>Als N&auml;chstes erstellen wir ein <code>Ext.form.Panel</code> im abgeleiteten <code>Ext.window.Window</code>. Hierzu verwenden wir die <code>initComponent</code>-Methode.</p>
				
<pre class="prettyprint linenums lang-js">initComponent: function() {
   var me = this;

   // Create form panel
   this.formPnl = Ext.create('Ext.form.Panel', {
      title: 'Formular',
      items: [{
         xtype: 'textfield',
         name: 'username',
         fieldLabel: 'Benutzername'
      }, {
         xtype: 'textfield',
         inputType: 'password',
         fieldLabel: 'Passwort'
      }],
      buttons: [{
         text: 'Abbrechen',
         action: 'cancelCreateUser'
         handler: function() { me.destroy(); }
      }, {
         text: 'Benutzer speichern',
         action: 'submitCreateUser',
         scale: 'large'
      }]
   });
   this.items = [ this.formPnl ];

   this.callParent(this);
}</pre>

				<p>
					Jetzt k√∂nnen wir in der Selenium IDE die Formularfelder jeweils mit Ihren Namen ansprechen. Der Selektor f&uuml;r das Feld "Benutzername" sieht dann wie folgt aus:
				</p>
				
<pre class="prettyprint-dark lang-css">div[id^=auth-main-create] input[name=username]</pre>


				<p>
					Um jetzt auch unser Formular zu speichern zu k&ouml;nnen, brauchen wir eine M&ouml;glichkeit den Submit-Button anzusprechen. Dazu wurde ein Override f&uuml;r den Standard ExtJS Button (<code>Ext.button.Button</code>) geschrieben, der die angegebene Action als HTML5 Data-Attribut hinterlegt. Im oberen Beispiel besitzt der Submit-Button die Action "submitCreateUser", so dass der DOM des Buttons wie folgt aussieht:
				</p>
				
				<p>
					<img src="selenium/dom-element-button.png" />
				</p>
				
				<p>
					Der Selektor f&uuml;r den Button sieht dann wie folgt aus:
				</p>
<pre class="prettyprint-dark lang-css">div[id^=auth-main-create] button[data-action=submitCreateUser]</pre>

				<p>
					<img src="selenium/selenium-2.png" />
				</p>
				</div>
			</div>
		</section>
		
		<section id="paging">
			<div class="page-header">
				<h2>PagingToolbar</h2>
			</div>
			
			<div class="row">
				<div class="span16">
					<p>
						Das Testen einer Paging-Toolbar funktioniert im Prinzip genauso wie das Testen von Fenstern oder Formularen. Durch den Override der <code>Ext.toolbar.Paging</code> stehen auf allen Buttons ein Data-Attribut zur Verf&uuml;gung, welches per Selektor angesprochen werden kann.
					</p>
					
					<ul>
						<li>erste Seite - <code>button[data-action=firstPage]</code></li>
						<li>vorherige Seite - <code>button[data-action=prevPage]</code></li>
						<li>n&auml;chste Seite - <code>button[data-action=nextPage]</code></li>
						<li>letzte Seite - <code>button[data-action=lastPage]</code></li>
						<li>Refresh - <code>button[data-action=refresh]</code></li>
					</ul>
					
					<p>
						Gehen wir davon aus, dass wir das selbe Fenster verwenden wie im Punkt "Adressierung" dann w&uuml;rde der Selektor f&uuml;r die komplette Paging-Toolbar wie folgt aussehen:
					</p>
					
<pre class="prettyprint-dark lang-css">div[id^=auth-main-create] div[id^=pagingtoolbar]</pre>

					<p>
						Die jeweiligen Buttons w&uuml;rde man z.B. f&uuml;r den Button "n&auml;chste Seite" wie folgt aussehen:
					</p>
					
<pre class="prettyprint-dark lang-css">div[id^=auth-main-create] div[id^=pagingtoolbar] button[data-action=nextPage]</pre>

					<p>
						Das Nummernfeld hat als <code>"name"</code>-Attribut "inputItem". Der Selektor, um dieses Feld anzusprechen, sieht wie folgt aus:
					</p>
<pre class="prettyprint-dark lang-css">div[id^=auth-main-create] div[id^=pagingtoolbar] input[name=inputItem]</pre>

				</div>
			</div>
		</section>
		
		<section id="combobox">
			<div class="page-header">
				<h2>Combobox</h2>
			</div>
			
			<div class="row">
				<div class="span16">
					<p>
						Das Testen von Comboboxen (<code>Ext.form.field.ComboBox</code>) gestaltet sich leider nicht ganz so einfach, da das angezeigte DropDown Men&uuml; nicht innerhalb der ComboBox selbst sondern am Ende des <code>body</code>-Elementes gerendert wird. Zudem wird das DropDown Men&uuml; komplett aus dem DOM gel&ouml;scht sondern einfach nur ausgeblendet (<code>style="display:none;"</code>). Fangen wir aber erstmal am Anfang an - das &Ouml;ffnen der ComboBox. Im folgenden erstellen wir eine Combobox (Modus "lokal") mit einen normalen <code>Ext.data.Store</code>.
					</p>
					
<pre class="prettyprint lang-js linenums">var store = Ext.create('Ext.data.Store', {
   fields: ['abbr', 'name'],
   data : [
      {"abbr":"AL", "name":"Alabama"},
      {"abbr":"AK", "name":"Alaska"},
      {"abbr":"AZ", "name":"Arizona"}
    ]
});

// Create the combo box, attached to the states data store
var combo1 = Ext.create('Ext.form.ComboBox', {
   fieldLabel: 'Choose State',
   store: store,
   queryMode: 'local',
   displayField: 'name',
   valueField: 'abbr',
   renderTo: Ext.getBody()
});</pre>
					
					<p>
						Um die Combobox zu &ouml;ffnen m&uuml;ssen wir einen <code>click</code> auf den Pfeil rechts neben der ComboBox ausf&uuml;hren.
					</p>
					
					<p>
						<img src="selenium/combobox-arrow.png" />
					</p>
					
					<p>
						Der passende Selektor sieht hier wie folgt aus:
					</p>
					
<pre class="prettyprint-dark">div[id^=combobox] div.x-form-arrow-trigger</pre>

					<p>
						Daraufhin warten wir bis das DropDown Men&uuml; ("boundlist" genannt) ge&ouml;ffnet wurde, indem wir per <code>waitForVisible</code> dies pr&uuml;fen. Der passende Selektor sieht hier dann wie folgt aus:
					</p>
					
<pre class="prettyprint-dark">body div[id^=boundlist]</pre>

					<p>
						Wie bereits erw&auml;hnt wird in ExtJS 4 das DropDown Men&uuml; nicht geschlossen sondern einfach nur per Inline CSS ausgeblendet. Es kann also nicht abgepr&uuml;ft werden ob das Element nicht mehr existiert (<code>waitForElementNotPresent</code>).
					</p>
					
					<p>
						<img src="selenium/combobox-dropdown.png" />
					</p>
					
					<p>
						Um zu testen ob ein Eintrag im DropDown Men&uuml; selektiert werden kann, sollte man darauf achten immer den letzten Eintrag zu selektieren. Hierzu kann folgender Selektor verwendet werden:
					</p>

<pre class="prettyprint-dark">body div[id^=boundlist] li:last-child</pre>

					<p>
						Als Letztes sollte gepr&uuml;ft werden ob sich das DropDown Men&uuml; wieder geschlossen hat. Daf&uuml;r bietet Selenium die Funktion <code>waitForNotVisible</code>.
					</p>
					
					<p>
						<img src="selenium/selenium-combobox.png" />
					</p>
				</div>
			</div>
		</section>
		
		<section id="ajax-combobox">
			<div class="page-header">
				<h2>AJAX-Combobox</h2>
			</div>
			
			<div class="row">
				<div class="span16">
					<p>
						Das Testen von AJAX basierten <code>Ext.form.field.ComboBox</code> funktioniert fast genauso wie das Testen von lokalen Comboboxen. Der Unterschied hierzu ist nur, dass eine "Loading"-Nachricht angezeigt wird, welche erst zus&auml;tzlich gepr&uuml;ft werden muss. Hier der Aufbau:
					</p>
<pre class="prettyprint lang-js linenums">// Set up a model to use in our store
Ext.regModel('Color', {
   fields: [
      { name: 'color', type: 'string' },
      { name: 'value', type: 'string' }
   ]
});

// Set up the store which holds our data
var store = Ext.create('Ext.data.Store', {
   model: 'Color',
   proxy: {
      type: 'ajax',
      url: './data.json',
      reader: {
         type: 'json',
         root: 'data'
      }
   }
});

// Create the combo box, attached to the states data store
var combo = Ext.create('Ext.form.ComboBox', {
    fieldLabel: 'Choose Color',
    store: store,
    queryMode: 'remote',
    displayField: 'color',
    valueField: 'value',
    renderTo: Ext.getBody()
});</pre>

				<p>
					Die verwendeten Daten k&ouml;nnen unter <a href="../playground/selenium/data.json">hier</a> eingesehen und heruntergeladen werden. Das &Ouml;ffnen der Combobox funktioniert wieder wie bei der lokalen Combobox.
				</p>
				
				<p>
					<img src="selenium/selenium-trigger-arrow.png" />
				</p>
				
<pre class="prettyprint-dark">div[id^=combobox] div.x-form-arrow-trigger</pre>

				<p>
					An dieser Stelle &ouml;ffnet sich jetzt die "Loading"-Nachricht auf die wir abpr&uuml;fen m&uuml;ssen um sicherzustellen, dass unsere Daten komplett geladen sind. Dazu verwenden wir die Selenium Methode <code>"waitForVisible"</code> mit folgenden Selektor.
				</p>
				
<pre class="prettyprint-dark">body div[id^=loadmask]</pre>

				<p>
					Jetzt pr&uuml;fen wir mit der Selenium Methode <code>"waitForNotVisible"</code>, ob die "Loading"-Nachricht ausgeblendet wurde = unsere Daten sind vollst&auml;ndig. Der Selektor f&uuml;r die "Loading"-Nachricht bleibt bestehen.
				</p>
<pre class="prettyprint-dark">body div[id^=loadmask]</pre>
				</div>
			</div>
		</section>
	</div>
	
	<script type="text/javascript" src="js/jquery-1.7.1.min.js"></script>
	<script type="text/javascript" src="js/bootstrap-dropdown.js"></script>
	<script type="text/javascript" src="js/jquery.checklist.js"></script>
	<script type="text/javascript" src="js/prettify.js"></script>
	<script type="text/javascript" src="js/lang-css.js"></script>
	<script>$(function () { prettyPrint(); })</script>
	</body>
</html>


body  p
body ~ p